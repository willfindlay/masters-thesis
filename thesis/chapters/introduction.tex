\begin{inprogress}
Virtualization is not confinement. To security experts, this may be an obvious statement,
but these two concepts are often conflated, leading to dangerous assumptions about
security in practice. To see why virtualization and confinement are disparate concepts,
consider the goals of each. \textit{Virtualization} describes the goal of providing
a unique, private mapping of shared system resources to a particular subject~\todo{CITE}
(be it a process, a virtualized operating system, or something else).
\textit{Confinement}, on the other hand, describes the goal of restricting a subjects
access to system resources or other subjects~\todo{CITE}. In other words, virtualization
is about \textit{what we can see}, whereas confinement is about \textit{what we can do}.
It should now be abundantly clear not only that virtualization and confinement are two
entirely different concepts, but that virtualization must be combined with confinement to
offer any practical security guarantees.

Container technologies on Linux offer a motivating example of the difference between
virtualization and confinement and how conflating the two can result in problematic
misunderstandings about the security of a system. From first principles, a container is
nothing more than a group of associated processes (and system resources) managed by some
container management engine (e.g.~Docker or \textit{lxc}). While often used for dependency
management, containers also offer lightweight virtualization and confinement using
a series primitives exposed by the operating system kernel.  Namespaces and cgroups
virtualize system resources while confinement layers such as \texttt{seccomp(2)} provide
some degree of isolation from the rest of the system~\todo{CITE}. Unfortunately, while
virtualization primitives are widely used in container deployments, the use of confinement
primitives is often overlooked, oversimplified, or overly permissive (i.e.~misconfigured)
in practice~\todo{CITE}.

Despite their name, containers do a very poor job of actually \textit{containing}
a running process.  The Linux kernel already supports a set of strong virtualization
primitives, namespaces and cgroups, that can be used to provide a process with a fairly
compartmentalized view of its environment. But these virtualization primitives do little
to improve the security of the applications that use them. Rather, such virtualization
serves much the same purpose as virtualization in other areas of computer science\,---\,to
allow two pieces of code to use the same name for different things and to abstract away
the complex details of the underlying system.

This thesis argues that the key to fixing isolation lies in improving our confinement
frameworks to work well in containerized applications. The status quo of process
confinement on Linux is a motley collection of unrelated technologies, each designed for
a specific purpose, often beyond the scope of simple process confinement. Container
management solutions cobble these technologies together, applying over-permissive,
coarse-grained defaults or compiling simple policies into a complex entanglement. To
rectify the status quo, we must rethink confinement from the ground up, and build
a confinement framework designed to be aware of the container model of computation.
\end{inprogress}


\section{Motivation}%
\label{s:motivation}

\begin{inprogress}
Container security issues are widely studied in the literature~\todo{CITE ALL EXAMPLES}.
\end{inprogress}


\section{Building a Container-Aware Security Model}%
\label{s:container-aware}


\section{Contributions}%
\label{s:contributions}
