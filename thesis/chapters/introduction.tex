\begin{inprogress}
Virtualization is not confinement. To security experts, this may be an obvious statement,
but these two concepts are often conflated, leading to dangerous assumptions about
security in practice. To see why virtualization and confinement are disparate concepts,
consider the goals of each. \textit{Virtualization} describes the goal of providing
a unique, private mapping of shared system resources to a particular subject~\todo{CITE}
(be it a process, a virtualized operating system, or something else).
\textit{Confinement}, on the other hand, describes the goal of restricting a subjects
access to system resources or other subjects~\todo{CITE}. In other words, virtualization
is about \textit{what we can see}, whereas confinement is about \textit{what we can do}.
It should now be abundantly clear not only that virtualization and confinement are two
entirely different concepts, but that virtualization must be combined with confinement to
offer any practical security guarantees.

Container technologies on Linux offer a motivating example of the difference between
virtualization and confinement and how conflating the two can result in problematic
misunderstandings about the security of a system. From first principles, a container is
nothing more than a group of associated processes (and system resources) managed by some
container management engine (e.g.~Docker or \textit{lxc}). While often used for dependency
management, containers also offer lightweight virtualization and confinement using
a series primitives exposed by the operating system kernel.  Namespaces and cgroups
virtualize system resources while confinement layers such as \texttt{seccomp(2)} provide
some degree of isolation from the rest of the system~\todo{CITE}. Unfortunately, while
virtualization primitives are widely used in container deployments, the use of confinement
primitives is often overlooked, oversimplified, or overly permissive (i.e.~misconfigured)
in practice~\todo{CITE}.

Despite their name, containers do a very poor job of actually \textit{containing}
a running process.  The Linux kernel already supports a set of strong virtualization
primitives, namespaces and cgroups, that can be used to provide a process with a fairly
compartmentalized view of its environment. But these virtualization primitives do little
to improve the \textit{security} of the applications that use them. Rather, such
virtualization serves much the same purpose as virtualization in other areas of computer
science\,---\,to allow two pieces of code to use the same name for different things and to
abstract away the complex details of the underlying system.

This thesis argues that the key to truly isolating containers from the rest of the system
lies in improving our confinement frameworks to work well in containerized applications.
The status quo of process confinement on Linux is a motley collection of unrelated
technologies, each designed for a specific purpose, often beyond the scope of simple
process confinement. Container management solutions cobble these technologies together,
applying over-permissive, coarse-grained defaults or compiling simple policies into
a complex entanglement. To rectify the status quo, we must rethink confinement from the
ground up, and build a confinement framework designed to be aware of the container model
of computation.

To improve the status quo of confinement on Linux, this thesis presents two research
systems, \bpfbox{} and its successor, \bpfcontain{}. The former is a novel application
sandboxing framework, and the latter extends that framework to work well in the context of
container security. Both research systems are implemented using a new Linux kernel
technology called \textit{Extended Berkley Packet Filter} (eBPF), a framework for
dynamically attaching simple filter programs to various system events and aggregating data
from these events on the fly in kernelspace. Using eBPF, we can safely extend the kernel
at runtime, building a new confinement model that suits the container use case without
detracting from existing confinement implementations or tying the kernel down to one
particular model.

An eBPF-based confinement mechanism provides several advantages over traditional
confinement models.  Firstly, eBPF is \textit{light-weight}. eBPF programs can monitor
many aspects of system behaviour, from userspace function calls to kernelspace function
calls, system calls, security hooks, and the networking stack. Data from these events can
be aggregated in real time in kernelspace, providing an extensible, performant, and
flexible framework for modelling relationships and enforcing policy decisions based on
these relationships.  A single security mechanism based on eBPF can combine the advantages
of several disparate mechanisms that would ordinarily need to be combined together to work
properly. This property precisely mirrors the way container security is currently done on
Linux. Rather than combining namespaces, cgroups, seccomp, and mandatory access control
together, eBPF provides the opportunity to design a single framework providing the
advantages of each.

A second advantage of eBPF in the confinement space is that it is \textit{dynamic}. \todo{FINISH}

\textit{Safety} is a third advantage provided by eBPF. \todo{FINISH}
\end{inprogress}


\section{Motivation}%
\label{s:motivation}

\begin{inprogress}
Containers are \textit{everywhere}. In the cloud, containers form the backbone of
cloud-native computation. Kubernetes~\todo{CITE} clusters drive the microservices that
power scalable web applications. In devops, Docker~\todo{CITE} containers often form the
backbone of continuous integration workflows, providing reproducible environments for
development, testing, and debugging. On the desktop, containerized package managers like
Snap~\todo{CITE}, FlatPak~\todo{CITE}, and AppImage~\todo{CITE} offer self-contained,
isolated software bundles, facilitating a smooth software installation process (mostly)
free of dependency management concerns.

Despite a steadily increasing prevalence, containers face major adoptability challenges in
deployments where they are expected to replace virtual machines.

Containers, in their current state, cannot be considered secure.
Container security issues are widely studied in the literature~\todo{CITE ALL EXAMPLES}.
\end{inprogress}


\section{Building a Container-Aware Security Model}%
\label{s:container-aware}


\section{Contributions}%
\label{s:contributions}


\section{Outline}%
\label{s:outline}
