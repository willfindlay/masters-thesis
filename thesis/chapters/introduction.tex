Virtualization is not confinement. To security experts, this may be an obvious statement,
but these two concepts are often conflated, leading to dangerous assumptions about
security in practice. To see why virtualization and confinement are disparate concepts,
consider the goals of each. \textit{Virtualization} describes the goal of providing
a unique, private mapping of shared system resources to a particular subject~\todo{CITE}
(be it a process, a virtualized operating system, or something else).
\textit{Confinement}, on the other hand, describes the goal of restricting a subjects
access to system resources or other subjects~\todo{CITE}. In other words, virtualization
is about \textit{what we can see}, whereas confinement is about \textit{what we can do}.
It should now be abundantly clear not only that virtualization and confinement are two
entirely different concepts, but that virtualization must be combined with confinement to
offer any practical security guarantees.

Container technologies on Linux offer a motivating example of the difference between
virtualization and confinement and how conflating the two can result in problematic
misunderstandings about the security of a system. From first principles, a container is
nothing more than a group of associated processes (and system resources) managed by some
container management engine (e.g.~Docker or \textit{lxc}). While often used for dependency
management, containers also offer lightweight virtualization and confinement using
a series primitives exposed by the operating system kernel. Namespaces and cgroups
virtualize system resources while confinement layers such as \texttt{seccomp(2)} provide
some degree of isolation from the rest of the system~\todo{CITE}. Unfortunately, while
virtualization primitives are widely used in container deployments, the use of confinement
primitives is often overlooked, oversimplified, or overly permissive (i.e.~misconfigured)
in practice~\todo{CITE}.

Despite their name, containers do a very poor job of actually \textit{containing}
a running process.  The Linux kernel already supports a set of strong virtualization
primitives, namespaces and cgroups, that can be used to provide a process with a fairly
compartmentalized view of its environment. But these virtualization primitives do little
to improve the \textit{security} of the applications that use them. Rather, such
virtualization serves much the same purpose as virtualization in other areas of computer
science\,---\,to allow two pieces of code to use the same name for different things and to
abstract away the complex details of the underlying system.

This thesis argues that the key to truly isolating containers from the rest of the system
lies in improving our confinement frameworks to work well in containerized applications.
The status quo of process confinement on Linux is a motley collection of unrelated
technologies, each designed for a specific purpose, often beyond the scope of simple
process confinement. Container management solutions cobble these technologies together,
applying over-permissive, coarse-grained defaults or compiling simple policies into
a complex entanglement. To rectify the status quo, we must rethink confinement from the
ground up, and build a confinement framework designed to be aware of the container model
of computation.

\todo{Missing something here?}

To improve the status quo of confinement on Linux, we present two research prototypes,
\bpfbox{} and its successor, \bpfcontain{}. The former is a novel application sandboxing
framework, and the latter extends that framework to work well in the context of container
security. Both research systems are implemented using a new Linux kernel technology called
\textit{Extended Berkley Packet Filter} (eBPF), a new Linux kernel mechanism for
dynamically attaching simple filter programs to various system events and aggregating data
from these events on the fly in kernelspace~\cite{gregg2019_bpf,starovoitov2014_ebpf}.
Using eBPF, we can safely extend the kernel at runtime, building a new confinement model
that suits the container use case without detracting from existing confinement
implementations or tying the kernel down to one particular model.


\section{Motivation}%
\label{s:motivation}

\subsection{Contextualizing the Problem}%
\label{ss:contextualizing-the-problem}

Containers are \textit{everywhere}. In the cloud, containers form the backbone of
cloud-native computation. Kubernetes~\todo{CITE} clusters drive the microservices that
power scalable web applications. In devops, Docker~\todo{CITE} containers often form the
backbone of continuous integration workflows, providing reproducible environments for
development, testing, and debugging. On the desktop, containerized package managers like
Snap~\todo{CITE}, FlatPak~\todo{CITE}, and AppImage~\todo{CITE} offer self-contained,
isolated software bundles, facilitating a smooth software installation process (mostly)
free of dependency management concerns.

Despite a steadily increasing prevalence, containers face major adoptability challenges in
deployments where they are expected to outright replace virtual machines. Unlike virtual
machines, which are abstracted away from the host and interact with a hypervisor,
containers interact directly with the host operating system kernel. This means that, while
much lighter-weight than hypervisor-based virtualization, containers are inherently less
isolated from each other and from the host system in general~\todo{CITE CONTAINER SECURITY
SURVEY}. In order to have truly secure containers, we must take great care to ensure
that a container is properly \textit{confined}. As we have already discussed,
virtualization primitives alone are not enough to achieve proper isolation. These
primitives \textit{must} be combined with confinement mechanisms and these confinement
mechanisms \textit{must} be applied properly.  Otherwise, we risk overprivilege, resulting
in potential violations of our security model.

Container security issues are widely studied in the literature~\todo{CITE ALL EXAMPLES}.

\subsection{Why eBPF?}%
\label{ss:why-ebpf}

An eBPF-based confinement mechanism provides several advantages over traditional
confinement models.  Firstly, eBPF is \textit{light-weight}. eBPF programs can monitor
many aspects of system behaviour, from userspace function calls to kernelspace function
calls, system calls, security hooks, and the networking stack. Data from these events can
be aggregated in real time in kernelspace, providing an extensible, performant, and
flexible framework for modelling relationships and enforcing policy decisions based on
these relationships.  A single security mechanism based on eBPF can combine the advantages
of several disparate mechanisms that would ordinarily need to be combined together to work
properly. This property precisely mirrors the way container security is currently done on
Linux. Rather than combining namespaces, cgroups, seccomp, and mandatory access control
together, eBPF provides the opportunity to design a single framework providing the
advantages of each.

A second advantage of eBPF for writing a security framework is that it is
\textit{dynamic}. eBPF programs can be loaded into the kernel dynamically and attached to
multiple events. Instrumenting a system event with eBPF can be done at runtime,
\textit{without} the need to modify the kernel in any way.  Similarly, eBPF maps, the
canonical runtime data store for eBPF programs, can be loaded, unloaded, modified, and
queried at runtime from both userspace and kernelspace, providing a rich substrate for
a dynamic model of system behaviour. These properties culminate in the ability to design
a flexible security mechanism without tying the kernel down to any one particular
abstraction. In the context of container security, this is a particularly important goal,
as containers are traditionally a \textit{userspace} concept, glued together with various
abstractions provided by the kernel.

\textit{Production-safety} is a third advantage provided by eBPF. All eBPF programs go
through a verification process before they are loaded into the kernel. The eBPF verifier
analyzes the program, asserting that it conforms to a number of safety requirements, such
as program termination\footnote{This property is enforceable due to the fact that eBPF
programs are not Turing complete~\cite{gregg2019_bpf}.}, memory safety, and read-only
access to kernel data structures. While itself not formally verified, the eBPF verifier
facilitates the adoption of new eBPF programs into production use cases, since an eBPF
program is far less likely to adversely impact a production system than other methods of
extending the kernel (e.g.~kernel patches and loadable kernel modules). In fact, eBPF is
already being used in production at large companies like Facebook, Netflix, and Google to
monitor server workloads for security and performance regressions~\cite{gregg2019_bpf}.
These factors make eBPF a promising choice for designing an \textit{adoptable} security
mechanism.

\todo{SUMMARIZE HERE}

\subsection{Why Design a New Confinement Framework?}%
\label{ss:why-new}

The process confinement problem dates back half a century~\cite{lampson1973_confinement}.
Since the advent of multi-processing \todo{IN WHAT YEAR? (e.g.~with Unix in 196X) CITE},
security experts have been concerned with designing systems in such a way that two running
programs minimally interfere with one another. Since then, an abundance of tools and
frameworks, some more practical than others, have been proposed to limit the damage that
untrusted software can do to the system as a whole~\cite{shu2016_security_isolation_study}.
These are covered in more depth in \Cref{c:background}. For now, we focus on why it might be
prudent to design yet another confinement framework amidst this veritable ocean of prior work.

In the context of Linux,

%\section{Building a Container-Aware Security Model}%
%\label{s:container-aware}


\section{Contributions}%
\label{s:contributions}


\section{Outline}%
\label{s:outline}
