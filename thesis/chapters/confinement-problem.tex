Researchers have been studying confinement for decades~\cite{lampson1973_confinement}, and
have been designing and applying confinement primitives since the early days of
time-sharing computers and multi-tenant systems~\cite{shu2016_security_isolation_study}.
Despite decades of research into the confinement problem, the status quo of confinement on
Linux, particularly from the perspective of containers, is in a sorry state. This chapter
outlines the difficulties that arise in the Linux confinement ecosystem due to its
inherent complexity, inflexible and interdependent components, and the difficulties that
arise in adopting newly-proposed alternatives. These insights represent the key
motivating factors behind the design of \bpfbox{} and \bpfcontain{} and can potentially
inform the way we think about new confinement mechanisms going forward.

\section{Fundamental Issues with Linux Confinement}%
\label{s:cp-confinement-issues}

\begin{enumerate}
  \item \textbf{Complexity and Interdependence.}
    Existing confinement primitives are overly complex and designed for use
    cases beyond simple process confinement. This results in a pattern of
    abusing existing mechanisms
  \begin{inprogress}
    \begin{itemize}
      \item Existing confinement solutions are overly complex
      \item Based on a number of low-level primitives that were originally designed for
            totally different tasks.
      \item Namespaces were designed to virtualize resources. They provide a form of
            isolation but not confinement; need a way to deal with namespace escapes
      \item Cgroups, similarly, were designed to virtualize the availability of system
            resources, not to directly confine.
      \item Unix \gls{dac} is far too coarse-grained and easy to bypass to be practically useful for confinement.
      \item POSIX capabilities can be used to reduce overprivilege by portioning root privileges, but do not
            implement confinement by themselves.
      \item Seccomp-bpf works well to reduce the availability of system calls, but writing
            classic \gls{bpf} filters is complex and error-prone. Anything beyond basic system call
            filtering quickly becomes untenable, particularly considering race conditions when
            checking arguments.
    \end{itemize}
  \end{inprogress}

  \item \textbf{Inappropriate Defaults.}
  \begin{inprogress}
    \begin{itemize}
      \item
    \end{itemize}
  \end{inprogress}

  \item \textbf{Difficulty Adopting New Solutions.}
  \begin{inprogress}
    \begin{itemize}
      \item Motivated by the above difficulties, academics are often tempted to propose new confinement solutions.
      \item Many try to solve the problem by simply recombining and reusing these existing primitives in new ways.
      \item This isn't really a step forward, as we are still subject to limitations introduced in item 1 and item 2.
      \item To really solve the problem, we need kernel-level support for something new.
      \item The issue is that new solutions based on kernel support are not necessarily
            adoptable. New kernel code can introduce bugs and security vulnerabilities, and
            needs to be thoroughly tested before it can be considered production-ready.
      \item Another problem arises when we consider container-specific confinement as an
            end goal; not everyone can agree on what the definition of a \enquote{container}
            even is, so how can we hope to reach agreement on what a new abstraction for
            container-based confinement would even look like.
      \item To solve this problem, we need a way to add new abstractions to the kernel in
            a way that is neither binding nor limited by the lack of adoptability associated
            with traditional kernel-based solutions.
    \end{itemize}
  \end{inprogress}
\end{enumerate}




\section{Confinement in Container Management Frameworks}%
\label{s:cp-containers}

\begin{inprogress}
  Container security policies are often overly-generic and ill-suited to fine-grained
  confinement. To achieve confinement in the first place, container frameworks cobble
  together existing confinement technologies and apply them in confusing and
  difficult-to-audit ways, overlapping and recombining default and generated policies. The
  end result is a complex security soup with little room for policy customization or
  auditability. \todo{Examples here}

  Even worse, many container management systems operate under a fail-open approach when the
  necessary security mechanisms are not supported. This results in low-security deployments,
  often without even notifying the user that there may be such a configuration. Since the
  end-user generally doesn't even participate in the policy authorship process, they may not
  even be aware of the level of protection that is being applied, resulting in a dangerous
  false sense of security. \todo{Examples here}
\end{inprogress}




\section{Design Goals}%
\label{s:design-goals}

Using the above analysis of the confinement problem, we can derive a clear set of design
goals for \bpfbox{} and \bpfcontain{}, such that they approach a solution to issues that
plague the status quo. In particular, we derive the following three design principles.
Note that these design principles are each the polar opposite of the three major problems
identified at the beginning of this chapter (c.f.~\Cref{s:cp-confinement-issues}).

\begin{enumerate}
  \item \textbf{Simplicity and Flexibility.}

  \item \textbf{Sensible Defaults.}

  \item \textbf{Adoptability.}
\end{enumerate}



\section{The \bpfbox{} and \bpfcontain{} Threat Model}%
\label{s:threat-model}
