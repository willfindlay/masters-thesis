In this chapter, we examine specific case studies, applying \bpfbox{} and \bpfcontain{}
policies to solve realistic problems. In particular, we examine the default Docker policy
and a more complex example confining a web server and database. We also provide an example
of how \bpfcontain{} can be used to apply basic confinement to an untrusted container. To
offer a basis for comparison, we contrast presented policies with some available
equivalents and discuss how the semantics of the policy language and enforcement engine
can impact the resulting policy file.

% \section{Methodology}

% \todo{This section will present the methodology used to select existing policies and
% compare them with \bpfbox{} and \bpfcontain{} policies}


\section{The Default Docker Policy}

Docker~\cite{docker_security} applies a coarse-grained default confinement policy to all
containers using a combination of Linux confinement primitives. On supported
systems\footnote{Recall that not all Linux distributions support AppArmor or Seccomp-bpf
to begin with. In such cases, Docker simply discards its default confinement policy
altogether.}, this includes a default AppArmor policy template~\cite{docker_apparmor,
docker_default_apparmor}, a default Seccomp-bpf profile, and a set of POSIX capabilities
which are dropped at runtime~\cite{docker_security}.

Docker's policy defaults are highly coarse-grained, with an emphasis on practical security
while ensuring that the vast majority of container configurations will \enquote{just
work,} out of the box. This affords a practical opportunity to examine how \bpfbox{} and
\bpfcontain{} policies compare with the default Docker policy. \Cref{tab:docker-default}
summarizes the key aspects of Docker's confinement policy, highlighting default access
levels enforced by various Linux confinement primitives. \Cref{lst:docker-default} depicts
Docker's default AppArmor template, taken directly from the Docker sources on
GitHub~\cite{docker_default_apparmor}.

\begin{table}[htpb]
  \centering
  \caption[The default Docker confinement policy]{
    A summary of Docker's default confinement policy~\cite{docker_security,
    docker_apparmor, docker_default_apparmor}. Policy is enforced using a number of Linux
    confinement primitives, including AppArmor, Seccomp-bpf, and dropped POSIX
    capabilities at runtime. Docker generates and loads AppArmor policy at container
    runtime using a pre-determined, coarse-grained AppArmor template file
    (c.f.~\Cref{lst:docker-default}).
  }%
  \label{tab:docker-default}
  \footnotesize
  \begin{tabular}{lp{2in}p{1.6in}}
  \toprule
  Access Category & Default & Docker Implementation \\
  \midrule
  Files & Allow access to all files except specific procfs and sysfs entries. & AppArmor Template \\
  Filesystem Mounts & Deny all filesystem mounts. & AppArmor Template \\
  POSIX Capabilities & All capabilities enabled in AppArmor.  Drop specific capabilities at runtime. & AppArmor Template and Dropped Capabilities \\
  Ptrace & Allowed within container. & AppArmor Template \\
  Signals & Allowed within container. & AppArmor Template \\
  Network & Allow all network access. & AppArmor Template \\
  \gls{ipc} & Allow all \gls{ipc} access. & AppArmor Template \\
  System Calls & Deny about 60 obsolete/dangerous system calls. & Seccomp-bpf \\
  \bottomrule
  \end{tabular}
\end{table}

\begin{lstlisting}[language=none, gobble=4,
  caption={[Docker's default AppArmor template]
    Docker's default AppArmor template~\cite{docker_default_apparmor}, at the time of
    writing this thesis. Docker uses Go's string templating syntax to modify the AppArmor
    profile according to the current Docker version and container metadata.
  },
  label={lst:docker-default}, float]
    {{range $value := .Imports}}
      {{$value}}
    {{end}}
    profile {{.Name}} flags=(attach_disconnected,mediate_deleted) {
    {{range $value := .InnerImports}}
      {{$value}}
    {{end}}
      network,
      capability,
      file,
      umount,
    {{if ge .Version 208096}}
      # Host (privileged) processes may send signals to container processes.
      signal (receive) peer=unconfined,
      # dockerd may send signals to container processes (for "docker kill").
      signal (receive) peer={{.DaemonProfile}},
      # Container processes may send signals amongst themselves.
      signal (send,receive) peer={{.Name}},
    {{end}}
     # deny write for all files directly in /proc (not in a subdir)
      deny @{PROC}/* w,
      # deny write to files not in /proc/<number>/** or /proc/sys/**
      deny @{PROC}/{[^1-9],[^1-9][^0-9],
        [^1-9s][^0-9y][^0-9s],[^1-9][^0-9][^0-9][^0-9]*}/** w,
      # deny /proc/sys except /proc/sys/k* (effectively /proc/sys/kernel)
      deny @{PROC}/sys/[^k]** w,
      # deny everything except shm* in /proc/sys/kernel/
      deny @{PROC}/sys/kernel/{?,??,[^s][^h][^m]**} w,
      deny @{PROC}/sysrq-trigger rwklx,
      deny @{PROC}/kcore rwklx,
      deny mount,
      deny /sys/[^f]*/** wklx,
      deny /sys/f[^s]*/** wklx,
      deny /sys/fs/[^c]*/** wklx,
      deny /sys/fs/c[^g]*/** wklx,
      deny /sys/fs/cg[^r]*/** wklx,
      deny /sys/firmware/** rwklx,
      deny /sys/kernel/security/** rwklx,
    {{if ge .Version 208095}}
      # suppress ptrace denials when using 'docker ps' or using 'ps' inside a container
      ptrace (trace,read,tracedby,readby) peer={{.Name}},
    {{end}}
    }
\end{lstlisting}

\subsubsection{\bpfbox{}}

We begin by examining a mostly equivalent policy in \bpfbox{}, given in
\Cref{lst:bpfbox-docker-default}.  Re-implementing Docker's default confinement policy in
\bpfbox{} is surprisingly challenging. \bpfbox{} is not designed to implement
coarse-grained confinement policy, and so specifying things like global access to all
files is impossible. We compromise by granting recursive access to all files within
a given filesystem, repeating the process for each filesystem as required. This is
\textit{not} the intended use case for \bpfbox{} file rules, but it is required to match
the over-permissive filesystem access provisioned by Docker. Aside from
filesystem-specific policy, most of Docker's default policy can be implemented relatively
easily and cleanly in \bpfbox{}'s policy language.

\begin{lstlisting}[language=bpfbox, gobble=4,
  caption={[Implementing the default Docker policy in \bpfbox{}]
    Implementing the default Docker policy in \bpfbox{}.
    %\todo{High-level overview of the policy}
  },
  label={lst:bpfbox-docker-default}]
    #![profile "/path/to/init/program"]

    #[allow] {
      /* Allow essentially global access to a filesystem */
      fs("/path/to/filesystem/**", read|write|setattr|getattr|rm|link|ioctl)
      /* Repeat for others... */

      /* Allow access to /proc/sys/kernel/shm* */
      fs("/proc/sys/kernel/shm*", read|write|setattr|getattr)

      /* Sensible default access for procfs per-pid entries */
      proc(self, read|write)
      proc(child, read|write)
    }

    #[allow]
    #[taint]
    {
      /* Access to network families */
      net(inet, any)
      net(inet6, any)
      net(unix, any)

      /* Ptrace child processes */
      ptrace(child, read|write|attach)

      /* Send sigchld up to parent processes, any signal to children */
      signal(parent, sigchld)
      signal(child, any)
    }

    #[transition]
    #[untaint]
    {
      /* Allow execve calls to allowed executables,
       * tainting and transitioning profiles when doing so */
      fs("/path/to/allowed/executable", read|exec)
      /* Repeat for others... */
    }
\end{lstlisting}

Like Docker's AppArmor policy, our \bpfbox{} policy enables access to per-pid entries in
procfs and uses \bpfbox{}'s default-deny enforcement to restrict all others. Similar logic
applies to the \texttt{/proc/sys/kernel/shm*} entries under procfs. We also grant full
networking stack access, ptrace access for child processes, and full signal access for
child processes running under the container. Since these operations have the potential to
introduce vulnerabilities from outside sources, we mark them as tainting the corresponding
process. Leveraging taintedness, the \bpfbox{} policy eliminates the need to specify
access to shared library dependencies and other artifacts of the C runtime.

For more complex container deployments that include more than a single binary, the
\bpfbox{} policy may need to specify access to alternative executables under the
container.  We do so using an individual file rule for each executable, optionally
specifying that the process should untaint itself and/or transition to a new profile.
Notably, the version of \bpfbox{} presented in this thesis does \textit{not} include
capability-level policy, and so it is not included here\footnote{\bpfcontain{} later
rectified this gap in \bpfbox{}'s policy language.}. However, the default Docker
confinement policy does not implement capability-level filtering anyway, instead relying
on dropped capabilities at runtime.

Although the \bpfbox{} policy depicted in \Cref{lst:bpfbox-docker-default} does not fully
map to the precise Docker default policy, it gets very close in most respects, aside from
filesystem policy. Under \bpfbox{}, filesystem policy is necessarily finer-grained, as it
does not support the ability to specify coarse-grained access to all files on the system.
Despite these challenges, the end-result is a functional (and, in some aspects, more
secure) alternative to the default Docker policy.

\subsubsection{\bpfcontain{}}

Having examined how \bpfbox{} can be used to implement an approximate version of Docker's
default confinement policy, we now turn our attention to \bpfcontain{}.
\Cref{lst:bpfcontain-docker-default} shows the full \bpfcontain{} policy. Note that many
aspects of Docker's default policy are covered by \bpfcontain{}'s default
container-boundary enforcement. Using this to its advantage, the \bpfcontain{} policy is
significantly simpler than both the AppArmor and \bpfbox{} versions while maintaining the
same level of expressiveness.

\begin{lstlisting}[language=yaml, gobble=4,
  caption={[Implementing the default Docker policy in \bpfcontain{}]
    Implementing the default Docker policy in \bpfcontain{}.
    %A few coarse-grained
    %allow-rules can be used to capture permissive Docker defaults that are not covered
    %under \bpfcontain{}'s default policy. Other aspects of the Docker defaults are already
    %covered under \bpfcontain{} defaults, such as the inability to mount filesystems,
    %perform a number of privileged system calls, and interact with non-pid entries in
    %procfs and sysfs. Due to \bpfcontain{}'s default policy for file access and \gls{ipc},
    %it is neither necessary to specify file access rules for files within the container's
    %overlay filesystem nor \gls{ipc} rules for processes within the container.
  },
  label={lst:bpfcontain-docker-default}]
    name: default-docker
    defaultTaint: true

    allow:
      # Grant access to the entire root filesystem
      fs: {pathname: /, access: any}
      # Grant access to tempfs
      fs: {pathname: /tmp, access: any}
      # Grant read/write access to /proc/sys/kernel/shm*
      file: {pathname: /proc/sys/kernel/shm*, access: rw}

      # Grant access to the terminal, /dev/null, /dev/random, and /dev/urandom
      device: terminal
      device: null
      device: random

      # Grant access to the entire networking stack
      net: any

      # Enable Docker default capabilities
      # All other capabilities are denied
      capability:
        - chown
        - dacoverride
        - fsetid
        - fowner
        - mknod
        - netraw
        - setgid
        - setuid
        - setfcap
        - setpcap
        - netbindservice
        - syschroot
        - kill
        - auditwrite
\end{lstlisting}

Compared with \bpfbox{}, the \bpfcontain{} version of Docker's default policy is
significantly simpler and fits more cleanly with Docker's AppArmor policy. This
improvement is a direct result of a number of critical differences between \bpfbox{} and
\bpfcontain{}. Whereas \bpfbox{} was designed for fine-grained, process-level confinement,
\bpfcontain{} was directly designed with containers in mind. Since \bpfcontain{} policies
are designed to be container-specific, they are far more appropriate for a use case
centered around the confinement of containers. In particular, \bpfcontain{} incorporates
container semantics into its default policy enforcement, greatly simplifying the resulting
policy.  Further, changes to \bpfcontain{}'s policy language, including the introduction
of a coarser-grained filesystem rule and capability rules enables the resulting policy to
more closely match the original Docker AppArmor policy.

To match Docker's default allow policy on filesystem access, the \bpfcontain{} policy
includes a rule to enable any file operation on files within the root filesystem and
tempfs.  As with \bpfbox{}, the point here is to match Docker's default policy, without
considering the security implications of granting full access to the entire root
filesystem. We include another rule to enable similar access on the temporary filesystem.
Despite the coarse granularity of these filesystem rules, \bpfcontain{} maintains
a critical advantage over \bpfbox{} and the original Docker policy. Due to its
container-specific policy defaults, we can achieve Docker's fine-grained protection over
procfs and sysfs for free. Thus, \bpfcontain{} entirely obviates the need to specify such
rules in the policy.

As with the procfs and sysfs policy, \bpfcontain{} also includes sensible defaults for
\gls{ipc} and ptrace access. In particular, processes running within the same container
are free to perform \gls{ipc} with one another and ptrace one another, so long as the
basic Unix access rights are satisfied (e.g.~the process possesses CAP\_PTRACE or is the
direct ancestor of the tracee). In the case of signals and ptrace, these defaults directly
match the Docker policy (c.f.~\Cref{tab:docker-default}).  In other cases, these defaults
are more secure than the Docker policy, while permits all other forms of \gls{ipc}
regardless of container membership.

To prevent a container from escaping confinement or interfering with the host,
\bpfcontain{} prohibits the container from mounting filesystems, loading kernel modules,
using \gls{ebpf}, changing the system time, rebooting the system, or performing a number
of other privileged operations. These defaults also match or exceed Docker's default
policy, and thus may also be omitted from the \bpfcontain{} policy.

While many aspects of \bpfcontain{}'s default enforcement closely match the default Docker
policy, \bpfcontain{}'s defaults remain strictly less permissive. For instance, the
default Docker policy mandates that \texttt{/proc/sys/kernel/shm*} be accessible to
containers, but \bpfcontain{} denies access to all procfs entries that do not belong to
a container process. We define an exception to \bpfcontain{}'s default procfs policy by
adding an explicit allow rule on this pathname. Similarly, \bpfcontain{}'s default policy
forbids network access by default, and so we must explicitly grant the container
permission to use the networking stack. Unlike Docker, \bpfcontain{} prohibits the use of
any POSIX capability that is not directly specified in the policy file. Thus, we include
an additional allow rule that mirrors the set of capabilities dropped by Docker at
runtime.

The resulting \bpfcontain{} policy implements a strict superset of Docker's default
confinement policy, despite being significantly simpler, and more centralized.  Since
\bpfcontain{} directly models the relationship between containerized processes and their
resources, we can achieve significant portions of Docker's default policy for free. In
many cases, this default enforcement is actually finer-grained than the Docker defaults.
In order to achieve the same coarse granularity as the Docker policy, we adjust the
\bpfcontain{} policy by incorporating a few additional allow rules, granting access to
specific filesystems, the networking stack, and POSIX capabilities.

\section{Confining an Untrusted Container}

We now examine perhaps the most obvious and practical use case for \bpfcontain{}:
confining and untrusted container. For instance, consider a new container image, freshly
downloaded from Docker Hub, to be used during application development or testing.  We
assume that the system administrator does not trust this container image, and wishes to
confine the resulting container, preventing it from damaging the rest of the system,
leaking information, or performing other potentially unwanted actions. For this purpose,
we leverage an extremely simple \bpfcontain{} policy (essentially the canonical
\enquote{Hello World} example) and demonstrate how it can be customized to match the
container's specific needs. \Cref{lst:bpfcontain-untrusted} depicts the \bpfcontain{} policy.

Here, we assume that this policy is applied to a future version of \bpfcontain{}
\textit{with} full Docker integration and automatic filesystem policy.
(\Cref{sss:bpfcontain-improving-default} of \Cref{c:bpfcontain} explains how this will be
done.) Without these extensions, the policy author would need to manually grant access to
files underlying the container's overlay filesystem, either using a filesystem allow rule
or per-file allow rules. While this shouldn't add much additional complexity to the
policy, the specific file rules would largely depend on the container's configuration, and
so we omit the details of such a policy here. For a similar reason, we omit the
corresponding \bpfbox{} policy as well, since \bpfbox{} does not deal in container-level
semantics as \bpfcontain{} does.

%\bpfcontain{}'s default
%enforcement policy of defining a boundary around the container enables this policy to
%be quite simple. A default-tainted policy enables container-level confinement without
%specifying \textit{any} rules whatsoever. This policy can then be adjusted as
%required, specifying file rules to provision access to volume mounts, network rules to
%enable networking, and capability rules to enable access to specific POSIX
%capabilities.

\begin{lstlisting}[language=yaml, gobble=4,
  caption={[Confining an untrusted container with \bpfcontain{}]
    Confining an untrusted container with \bpfcontain{}.
    Note that this policy requires some extensions on top of the existing \bpfcontain{}
    model, such as instrumenting the Docker container runtime.
  },
  label={lst:bpfcontain-untrusted}, float=false]
    name: untrusted-container
    defaultTaint: true

    allow:
      # Specify full path and access for volume mounts from the host
      file: {pathname: /path/to/volume/mount, access: rw}
      # Repeat for other volume mounts as required...

      # If the container requires networking
      # We could also define finer-grained access by replacing the "any"
      # keyword with specific socket operations
      net: any

      # If the container requires any capabilities
      capability: [dacoverride, dacreadsearch, netbindservice] # etc.

      # Further extensions to the policy as required...
\end{lstlisting}

We define a default-tainted \bpfcontain{} policy called \enquote{untrusted-container}.
Just this policy alone should be enough to confine a simple container. \bpfcontain{}'s
default policy would prohibit network access, the use of any POSIX capabilities, access to
any files outside of the container's overlay filesystem, and any operations that can
impact the system as a whole. This default policy prevents entire classes of attacks,
prohibiting the container from leaking outside information, changing global system
parameters, loading code into the kernel, or forming unauthorized network connections. The
reader is encouraged to revisit \Cref{fig:bpfcontain-enforcement} on page
\pageref{fig:bpfcontain-enforcement} of \Cref{c:bpfcontain} for a depiction of how
\bpfcontain{}'s default enforcement works.

While the \bpfcontain{} default policy should be sufficient for simple use cases, more
advanced container images may require some slight modification, introducing a few allow
rules to define exceptions in \bpfcontain{}'s protection boundary. For instance, suppose
the container image requires a docker volume to be mounted at runtime. To support this use
case, we define a file rule, specifying the system path to the volume mount and the
corresponding access pattern, such as \texttt{rw} for read and write access. All other
accesses to the host filesystem remain denied. If the container requires access to the
networking stack, we similarly define a net rule.  Capability rules can be used to allow
the container to use a selected subset of POSIX capabilities, assuming it already
possesses these capabilities at runtime. For example, we may wish to grant the container
the \texttt{DAC\_OVERRIDE} and \texttt{DAC\_READ\_SEARCH} capabilities to allow it to
interact with the Docker volume we specified earlier, or the \texttt{NET\_BIND\_SERVICE}
capability to allow it to bind to privileged ports.

% \todo{\bpfbox{} is not the right tool for this job, so we won't offer a comparable \bpfbox{} policy here}
% Note that \bpfbox{} is not the correct tool for this job. Without \bpfcontain{}'s semantic
% defaults, a \bpfbox{} policy would need to manually specify every single access required
% for the container to function. Thus, it is impossible to design a generically-applicable
% solution using \bpfbox{}. The key advantage of \bpfcontain{} here is that it can use
% container semantics to infer a default protection boundary for the container. This greatly
% simplifies the resulting policy while ensuring that the container is unable to access
% resources outside of its protection boundary, unless otherwise specified. The resulting
% \bpfcontain{} policy is just a few lines long.

\section{Confining a Web Server and Database}

We now turn our attentions to a more nuanced use case: confining a simple web server and
database deployment. In particular, we focus on the Apache httpd web server and the MySQL
data base management system. These two pieces of software are often used together (e.g.~as
part of the LAMP stack~\todo{CITE}) and provide a good example of how we can define
specific policy exceptions to allow two processes or containers to communicate with each
other, and with the outside world. In this example, we assume that httpd and mysqld
communicate with each other using a shared Unix domain socket, created by mysqld.

\subsubsection{\bpfbox{}}

In \bpfbox{}, we define two profiles: one for httpd, and one for mysqld.
\Cref{lst:bpfbox-apache} depicts the httpd policy, while \Cref{lst:bpfbox-mysql} depicts
the mysqld policy. These policies are simplified examples, but provide a representative
idea of what it's like to confine a complex application down to its basest functionality.

The httpd policy (\Cref{lst:bpfbox-apache}) defines allow and taint rules for three
categories of socket access: \texttt{inet}, \texttt{inet6}, and \texttt{unix}. These
categories cover IPv4 and IPv6 network access, as well as \gls{ipc} over a Unix domain
socket. This Unix domain socket is what httpd will use to communicate with the database.
By defining these network rules as both allow and taint, we indicate that default-deny
enforcement should begin only \textit{after} the Apache daemon has begun interacting with
the outside world. Using this technique, the \bpfbox{} policy may be greatly simplified by
eliminating the need to define any policy corresponding to the setup phase of httpd.

The bulk of the \bpfbox{} policy is made up of filesystem rules, enabling access to
a variety of configuration files that httpd needs to read at runtime, a few informational
files exposed by the kernel under procfs, shared libraries that may be loaded at runtime,
the mysqld Unix socket, and the directory that httpd will use to serve web content. We
also define a rule allowing httpd to run suexec, a helper application used to launch
\gls{cgi} scripts.  We indicate that launching suexec should untaint the process and
transition to a suexec profile.  This profile would then define the access control policy
for suexec (e.g.~which scripts it is allowed to run).

\clearpage

\begin{lstlisting}[language=bpfbox, gobble=4, float=false, caption={[A \bpfbox{} policy for Apache httpd]
  A \bpfbox{} policy for Apache httpd.
  %\todo{Describe this}
}, label={lst:bpfbox-apache}]
    #![profile "/bin/httpd"]

    /* Allow IP and Unix socket operations, and taint when they occur */
    #[allow]
    #[taint] {
      net(inet, any)
      net(inet6, any)
      net(unix, any)
    }

    #[allow] {
      /* Allows kill(2) to check for process existence
       * and to send fatal signals */
      signal("/bin/httpd", check|fatal)

      /* Write to logs */
      fs("/var/log/httpd/*log", getattr|read|append)
      fs("/var/log/httpd", getattr|read|write)

      /* Create PID file */
      fs("/run/httpd/", write)
      /* Delete or modify an existing PID file if necessary */
      fs("/run/httpd/httpd.pid", getattr|rm|write)

      /* Serve files from /srv/html/ and all subdirectories */
      fs("/srv/html/**", read|getattr)

      /* Access to mysqld socket */
      fs("/run/mysqld", getattr|read)
      fs("/run/mysqld/mysqld.sock", getattr|read|write)

      /* Read configuration */
      fs("/usr/share/httpd/**", read|getattr)
      fs("/etc/httpd/", getattr)
      fs("/etc/httpd/conf/**", read|getattr)
      fs("/usr/share/zoneinfo/**", read|getattr)

      /* Read hostname information */
      fs("/etc/resolv.conf", read|getattr)
      fs("/etc/host*", read|getattr)

      /* Read-only access to required kernel info */
      fs("/proc/sys/kernel/random/boot_id", read)
      fs("/proc/sys/kernel/ngroups_max", read)

      /* Shared libraries loaded at runtime */
      fs("/usr/lib/httpd/modules/*.so", getattr|read|exec)
      fs("/usr/lib/libnss*.so.*", getattr|read|exec)
      fs("/usr/lib/libgcc_s.so.*", getattr|read|exec)
    }

    /* Transition to a separate suexec policy */
    #[transition] {
      fs("/usr/bin/suexec", getattr|read|exec)
    }
\end{lstlisting}

The \bpfbox{} policy for mysqld works in much the same way as the policy for httpd. Major
differences include disabling all socket access except to Unix domain sockets. This
ensures that the database is not exposed to the outside world, but still enables is to
communicate with httpd over its Unix socket. Like with httpd, we define specific rules
enabling mysqld to read important configuration files, log events, create and modify its
\gls{pid} file and Unix socket, and load some shared libraries at runtime. The entire
setup phase for mysqld occurs while the process is untainted, thus allowing us to
eliminate rules for any shared libraries loaded before the process becomes tainted.

\begin{lstlisting}[language=bpfbox, gobble=4, float=false, caption={[A \bpfbox{} policy for MySQL]
  A \bpfbox{} policy for MySQL.
  %\todo{Describe this}
}, label={lst:bpfbox-mysql}]
    #![profile "/bin/mysqld"]

    /* Allow Unix socket operations, and taint when they occur */
    #[allow]
    #[taint] {
      net(unix, any)
    }

    #[allow] {
      /* Allows kill(2) to check for process existence
       * and to send fatal signals */
      signal("/bin/mysqld", check|fatal)

      /* Write to logs */
      fs("/var/log/mysqld/*log", getattr|read|append)
      fs("/var/log/mysqld", getattr|read|write)

      /* Access to /var/lib/mysqld */
      fs("/var/lib/mysqld", read|write|getattr)
      fs("/var/lib/mysqld/**", read|write|getattr|rm)

      /* Create PID file and socket */
      fs("/run/mysqld", getattr|read|write)
      fs("/run/mysqld/**", getattr|read|write|rm)

      /* Read configuration */
      fs("/etc/mysqld", read|getattr)
      fs("/etc/mysqld/**", read|getattr)
      fs("/usr/share/zoneinfo", read|getattr)
      fs("/usr/share/zoneinfo/**", read|getattr)

      /* Read hostname information */
      fs("/etc/resolv.conf", read|getattr)
      fs("/etc/host*", read|getattr)

      /* Shared libraries loaded at runtime */
      fs("/var/lib/mysql/plugin/*.so", getattr|read|exec)
    }
\end{lstlisting}

\subsubsection{\bpfcontain{}}

In \bpfcontain{}, we once again define a policy for httpd and a policy for mysqld.  These
policies are depicted in \Cref{lst:bpfcontain-apache} and \Cref{lst:bpfcontain-mysql}
respectively. These policies are largely similar to the \bpfbox{} policies, with a few
minor differences that can be attributed to \bpfcontain{}'s nuanced policy defaults and
its updated policy language.

Like \bpfbox{}, the majority of the \bpfcontain{} httpd policy
(\Cref{lst:bpfcontain-apache}) focuses on specifying filesystem access for httpd. Since
\bpfcontain{} also supports tainting semantics, we leverage these to eliminate the need to
define rules for operations preceding the taint. Specifically, we taint container once it
has performed any networking operations or any \gls{ipc} with mysqld. Unlike \bpfbox{},
however, \bpfcontain{} does not support untainting a process\footnote{This is because
\bpfcontain{} taints at the container-level rather than the process-level. Future
iterations of \bpfcontain{} may change this behaviour, for example by tainting at the
container-level and untainting at the process-level.}. \todo{Remove the footnote, talk
about how \bpfcontain{} deals in a different policy abstraction, and therefore tainting
and switching policies doesn't make sense. We have no notion of transitioning from one
policy to another.} This means that we must still specify access to shared libraries that
will be loaded by suexec (along with whatever applications suexec will run, such as
Python).

Aside from the aforementioned differences, the per-file policy is more or less the same as
\bpfbox{}.  To enable \gls{ipc} between the httpd and mysql, we define an \gls{ipc} allow
rule that lists the mysqld policy. We also enable socket networking using a network allow
rule and enable signalling of existing instances of httpd with a signal rule. Finally,
we use a capability rule to grant access to the \texttt{CAP\_NET\_BIND\_SERVICE} capability,
allowing httpd to bind to privileged ports. Since \bpfbox{} does not support capability rules,
there is no equivalent to this rule in the \bpfbox{} policy.

\begin{lstlisting}[language=yaml, gobble=4, float=false, caption={[A \bpfcontain{} policy for Apache httpd]
  A \bpfcontain{} policy for Apache httpd.
  %\todo{Describe this}
}, label={lst:bpfcontain-apache}]
    name: httpd
    defaultTaint: false

    allow:
      # Access to log files
      file: {pathname: /var/log/httpd, access: rw}
      file: {pathname: /var/log/httpd/*log, access: ra}

      # Create pidfile, delete or modify an existing pid file if necessary
      file: {pathname: /run/httpd, access: rw}
      file: {pathname: /run/httpd/**, access: rwd}

      # Read configuration
      file: {pathname: /usr/share/httpd/**, access: r}
      file: {pathname: /etc/httpd, access: r}
      file: {pathname: /etc/httpd/conf/**, access: r}
      file: {pathname: /usr/share/zoneinfo/**, access: r}

      # Read hostname information
      file: {pathname: /etc/resolv.conf, access: r}
      file: {pathname: /etc/host*, access: r}

      # Shared libraries loaded at runtime
      file: {pathname: /usr/lib/httpd/modules/*.so, access: mr}
      file: {pathname: /usr/lib/libnss*.so.*, access: mr}
      file: {pathname: /usr/lib/libgcc_s.so.*, access: mr}

      # Execute suexec and python
      file: {pathname: /usr/bin/suexec, access: rx}
      file: {pathname: /usr/bin/python, access: rx}

      # Shared libraries required for suexec and python
      # This is unfortunately required since BPFContain currently
      # has no notion of untainting like BPFBox
      file: {pathname: /usr/lib/libpython*.so.*, access: mr}
      file: {pathname: /usr/lib/libc.so.*, access: mr}
      file: {pathname: /usr/lib/libpthread.so.*, access: mr}
      file: {pathname: /usr/lib/libdl.so.*, access: mr}
      file: {pathname: /usr/lib/libutil.so.*, access: mr}
      file: {pathname: /usr/lib/libm.so.*, access: mr}
      file: {pathname: /usr/lib64/ld-linux-x86-64.so.*, access: mr}

      # Allow ipc with mysql
      ipc: mysqld

      # Allow sending signals to existing httpd instances
      ipc: httpd

      # Bind to privileged ports
      capability: [netbindservice]

      # Use networking
      net: [server, send, recv]

    taint:
      # Taint when performing any ipc or networking
      net: any
      ipc: mysqld
\end{lstlisting}

The mysqld policy for \bpfcontain{} (\Cref{lst:bpfcontain-mysql}) also shares many
similarities with the \bpfbox{} version.  In particular, we define equivalent file access
rules to enable the mysqld to access all of the files it requires for normal operation. We
define an \gls{ipc} rule, granting mutual \gls{ipc} access to the httpd policy, and
enabling the two to communicate with each other. We taint the container once it has
performed any \gls{ipc} with httpd.

\begin{lstlisting}[language=yaml, gobble=4, float=false, caption={[A \bpfcontain{} policy for MySQL]
  A \bpfcontain{} policy for MySQL.
  %\todo{Describe this}
}, label={lst:bpfcontain-mysql}]
    name: mysqld
    defaultTaint: false

    allow:
      # Access to log files
      file: {pathname: /var/log/mysqld, access: rw}
      file: {pathname: /var/log/mysqld/*log, access: ra}

      # Access to /var/lib/mysql
      file: {pathname: /var/lib/mysqld, access: rw}
      file: {pathname: /var/lib/mysqld/**, access: rwd}

      # Create pidfile and socket
      file: {pathname: /run/mysqld, access: rw}
      file: {pathname: /run/mysqld/**, access: rwd}

      # Read configuration
      file: {pathname: /etc/mysqld, access: r}
      file: {pathname: /etc/mysqld/**, access: r}
      file: {pathname: /usr/share/zoneinfo, access: r}
      file: {pathname: /usr/share/zoneinfo/**, access: r}

      # Read hostname information
      file: {pathname: /etc/resolv.conf, access: r}
      file: {pathname: /etc/host*, access: r}

      # Shared libraries loaded at runtime
      file: {pathname: /var/lib/mysql/plugin/*.so, access: mr}

      # Allow ipc with httpd
      ipc: httpd

      # Allow sending signals to existing mysqld instances
      ipc: mysqld

    taint:
      # Taint when performing any ipc
      ipc: httpd
\end{lstlisting}

\subsubsection{Simplifying the \bpfcontain{} Example}

Once \bpfcontain{} has been fully integrated with Docker support, we can greatly simplify
the above policy examples, leveraging default filesystem policy to grant access to all of
the required files, without the need to explicitly specify rules for each file. We
leverage a shared \texttt{/tmp} filesystem, mounted on the host, to allow both mysqld and
httpd to access the same Unix socket. The result is an extremely simple policy that can
express all the required interfaces in just a few lines. \Cref{lst:bpfcontain-httpd-next}
and \Cref{lst:bpfcontain-mysqld-next} give example policies for httpd and mysqld
respectively.

\begin{lstlisting}[language=yaml, gobble=4, float=false, caption={[A simplified \bpfcontain{} policy for Apache httpd]
  A simplified \bpfcontain{} policy for Apache httpd running in a Docker container,
  leveraging future support for automatic filesystem policy.
  %\todo{Describe this}
}, label={lst:bpfcontain-httpd-next}]
    name: httpd-container
    defaultTaint: true

    allow:
      # Grant access to global /tmp filesystem, mounted as a Docker volume
      # This is where the mysqld Unix socket will go
      fs: {pathname: /tmp, access: rw}
      # Allow network access
      net: [server, send, recv]
      # Allow ipc access with mysqld
      ipc: mysqld-container
      # Bind to privileged ports
      capability: [netbindservice]
\end{lstlisting}

\begin{lstlisting}[language=yaml, gobble=4, float=false, caption={[A simplified \bpfcontain{} policy for MySQL]
  A simplified \bpfcontain{} policy for MySQL running in a Docker container, leveraging
  future support for automatic filesystem policy.
  %\todo{Describe this}
}, label={lst:bpfcontain-mysqld-next}]
    name: mysqld-container
    defaultTaint: true

    allow:
      # Grant access to global /tmp filesystem, mounted as a Docker volume
      # This is where the mysqld Unix socket will go
      fs: {pathname: /tmp, access: rw}
      # Allow ipc access with httpd
      ipc: httpd-container
\end{lstlisting}

\section{Summary}

This chapter has presented and compared \bpfbox{} and \bpfcontain{} policies for various
use cases. In particular, we examine how each system can be used to implement a policy
resembling the Docker default policy, how \bpfcontain{} can be used to confine an
untrusted container, and how \bpfbox{} and \bpfcontain{} can confine a simple web server
and database deployment. We find that each confinement mechanism has its respective
strengths and weaknesses.  \bpfcontain{} supports more access categories and combines
semantically related accesses into the same rule types, simplifying policies and providing
increased expressiveness. However, \bpfbox{}'s tainting and untainting semantics prove
advantageous for complex deployments on the host system. Future iterations on
\bpfcontain{}'s default policy can greatly simplify existing container-specific policy
semantics, shortening long and complex policies down to just a few lines.
